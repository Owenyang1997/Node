## 阻塞IO模型
* 首先明确IO过程涉及到 内核函数调用，比如一次socket传输：
应用程序写数据到用户缓存，调用内核函数，将数据copy到内核缓存，传输到网卡（IO接口），在网络上传输，主机B接收到，然后从网卡读取到内核缓存，然后copy到用户缓存，
应用程序才能读取数据。这个过程提供了两个系统调用Write() 和 Read();
1. 阻塞IO : 上面数据传输过程中，涉及的两个系统调用函数write和read都是阻塞的，当用户缓存没有数据的时候，应用程序处于阻塞状态。
2. 非阻塞IO: read()函数非阻塞，没有读到数据直接返回，cpu需要不断调用read一直到读到数据。只有数据从内核copy到用户缓存是阻塞的。
  通过轮询方式避免了阻塞，但是十分消耗cpu资源
3. I/O多路复用: 通过select,poll,epoll阻塞调用，监听是否有事件发生，如果有事件发生才会让用户调用read（阻塞）,处理事件。
   select: 多路复用器，轮询检测所有连接，判断是否有事件发生，发生事件，将发生事件的连接取出，然后处理。底层使用数组实现，连接数量有限
   poll:底层使用链表实现，连接数量无上限。
   epoll:使用事件驱动，有事件发生的时候，将发生事件的连接取出，进行处理，不需要变量，采用事件驱动，发生事件回调，底层使用哈希表，连接无上限。
    
