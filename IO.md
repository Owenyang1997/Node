## 阻塞IO模型
* 首先明确IO过程涉及到 内核函数调用，比如一次socket传输：
应用程序写数据到用户缓存，调用内核函数，将数据copy到内核缓存，传输到网卡（IO接口），在网络上传输，主机B接收到，然后从网卡读取到内核缓存，然后copy到用户缓存，
应用程序才能读取数据。这个过程提供了两个系统调用Write() 和 Read();
* 一个线程处理一个连接，这样当没有数据可读的时候，线程阻塞在Read()上，不影响其他线程。
* 使用线程池，解决连接问题，同时一个线程处理多个连接，但是如果线程阻塞，其他连接有数据也无法处理。
* 非阻塞IO,read()系统调用不阻塞，直接返回，通过轮询的方式判断是否有数据。
* 判断是否有数据需要轮询是否有方案解决（系统调用很浪费资源）？
* 使用多路复用，select/poll/epoll系统调用，监听所有连接，当无事件发生，处于阻塞，如果发生事件，将连接拿出来处理。
1. select: 将文件描述符数组交给操作系统，（调用select函数）操作系统遍历，将发生事件的文件描述符标记，用户再遍历一次处理。(没有数据不需要无用的系统调用)
2. poll: 文件描述符没有现在，底层使用链表存储文件描述符
3. epoll: 首先用户无需将文件描述符传到操作心态，其次不需要无效遍历，采用异步事件通知就可以知道那些文件有事件发生。
   具体是三个系统调用函数：
   * epoll_creat():创建文件描述符，（红黑树结构存储）
   * epoll_ctl():向内核同步要修改，添加，删除的文件描述符
   * epoll_wait():将发生事件的文件描述符返回用户，或者阻塞，让出cpu。

1. 阻塞IO : 上面数据传输过程中，涉及的两个系统调用函数write和read都是阻塞的，当用户缓存没有数据的时候，应用程序处于阻塞状态。
2. 非阻塞IO: read()函数非阻塞，没有读到数据直接返回，cpu需要不断调用read一直到读到数据。只有数据从内核copy到用户缓存是阻塞的。
  通过轮询方式避免了阻塞，但是十分消耗cpu资源
3. I/O多路复用: 通过select,poll,epoll阻塞调用，监听是否有事件发生，如果有事件发生才会让用户调用read（阻塞）,处理事件。
   select: 多路复用器，轮询检测所有连接，判断是否有事件发生，发生事件，将发生事件的连接取出，然后处理。底层使用数组实现，连接数量有限
   poll:底层使用链表实现，连接数量无上限。
   epoll:使用事件驱动，有事件发生的时候，将发生事件的连接取出，进行处理，不需要变量，采用事件驱动，发生事件回调，底层使用哈希表，连接无上限。
 
 
 
