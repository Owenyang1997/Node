## java中有哪些引用类型？
强应用，软引用，弱引用，虚引用。强应用，GC不会删除。软引用，指向的对象，会在内存不足时被GC清除，弱引用：无论内存是否足够，遇到弱引用的对象，GC会清除。
虚引用：一种甚至无法找到对象的引用，用来标识对象已经被清除，加入引用队列。

## 运行时数据区？
  * 虚拟机栈：线程私有，由一个个栈帧构成，栈帧结构：局部变量表，操作数栈，动态连接，方法返回地址。主要存储临时变量，引用变量等局部变量
  * 堆区：存储对象实例数据。
  * 方法区：存放对象类信息，字段信息，方法信息，常量，静态变量
  * 程序计数器：用来记录程序执行的下一条指令位置，可以定位程序执行的位置，程序中断返回时快速恢复。
  * 本地方法栈：调用本地方法的时候使用的栈。
 注意：
   堆：<=1.7 的时候 划分为：年轻代，老年代，永久代 ，>=1.8 划分为 年轻代，老年代，元空间（变为直接内存）
   方法区：是一个概念，落地实现是，永久代和元空间，1.7之前，字符串常量池在永久代中--> 1.7将字符串常量池移到堆中--->1.8 永久代变为元空间
   为什么将字符串常量池移到堆中? 永久代，很少有GC,二字符串的创建存在大量失活对象，需要GC,所以移到到堆区。

## 讲一下 Java 创建一个对象的过程 ?
1. 类加载检测
   遇到New指令，检测指令的参数能否在常量池中找到类的符合引用，并检查该符号应用对应的对象是否被加载，连接，解析过。如果没有执行加载操作。
2. 分配内存
  类在加载检测通过后，为对象在堆内分配内存，两种分配方式，指针碰撞，和空闲列表
  指针碰撞：将用过的内存移到一段，未用的在另一端，中间使用指针标记，需要划分内存，移动指针即可（内存规整）
  空闲列表：维护一个可以使用的内存块列表，分配是找一个足够的内存块分配。然后更新列表。（内存零散）
3. 初始化零值
  将堆区分配的空间初始化0值，不包括对象头。
4. 设置对象头
  将对象的信息存储在对象头中，比如类信息，哈希码，对象代数，锁信息。
5. 指向init方法
  执行<init>方法，为属性初始化赋值操作。
注意：对象存在线程安全问题，JVM如何解决的呢？
  * CAS+失败重试: 乐观锁，方式保证更新原子性操作
  * TLAB(Thread Local Allocation Buffer): 每个线程都有一个独享的堆内存空间（在Eden区），创建对象首先在TLAB中，如果对象大小大于TLAB采用方案1保证线程安全。
  
## 如何回收方法区？

## 垃圾回收算法？
  1. 标记清除：先标记存活对象，然后清除死亡的对象，存在大量内存碎片。
  2. 标记整理：先标记存活对象，然后将存活对象移到一段。解决了内存碎片问题。用在老年代，只有少数对象死亡，需要移到。
  3. 标记复制：将内存分为两块，分配使用一块，用完的时候标记，将存活的对象复制到另一块，然后清除这一块内存。在新生代使用，每次只有少数对象存活，复制少。

## 垃圾回收器？ 
  1. 

## 新生代使用那些垃圾回收器，老年代使用那些垃圾回收器，各有什么特点？

## 讲一下CMS垃圾回收器？

## 类的生命周期？

## 类的加载过程？
  将.calss文件加载到方法区，并在堆区生成一个Class对象。提供程序员访问方法区内数据结构的接口。 
  加载-->连接-->初始化
 * 加载： 
    1. 通过类的全限定名获取类定义的二进制字节 
    2. 将静态数据结构转化为方法区动态的数据结构 
    3. 在堆区生成一个代表该类的Class对象，作为方法区这些数据结构的访问接口。 
 * 连接： 
    1. 验证  
        * 字节码验证：是否符号java语法  
        * 元数据验证：语义分析，是否符合JAVA语法规范  
        * 文件格式验证：是否符合Class文件格式规范  
        * 符号引用验证：符合引用能否正确解析  
    2. 准备  
        * 为类的静态变量分配内存，初始化默认值。 
    3. 解析  
        * 将符号引用转为直接引用。 
 * 初始化：  
        * 执行<init>方法，初始化静态变量，静态代码块。
 最终在堆内生成一个大Class对象。    
