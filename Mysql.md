# Mysql
## 索引
### 索引原理
数据库如何查找我们所需的数据呢？如果没有索引，会进行全表扫描，这样如果数据表数据很大，会有很多次I/O操作，磁盘I/O会大大降低性能。为减少I/O操作引入了索引，底层使用B+树，将索引列加载到内存，数据全部在叶子节点，可以大大减少I/O操作，并且可以很快定位到我们所需要的数据，只需要很少的I/O操作将我们所需数据加载到内存放回就行，不需要将全表内容加载到内存。  
<div algin="center">
<img src=https://user-images.githubusercontent.com/34670345/175211944-c773dcc9-cb24-426c-99e7-482cec78e3cf.jpg height=350px />
</div>

### 分类
* 按照存储结构分类
1. 聚集索引：叶子节点存储了数据，不是指向数据的指针。
2. 非聚集索引：叶子阶段存储了指向数据的指针。
* 按照应用角度分类
1. 唯一索引：可以确保被索引的字段不存在重复值。
2. 单列索引，在单个字段上创建的索引。
3. 多列索引，在多个字段组合创建索引，也称为复合索引。

### 索引维护
1. 索引创建
```text
creat [unique] index index_name on table_name(coll [ASC|DESC], ...);
```
ASC: 升序，DESC: 降序，unique:唯一索引。我们创建主键和唯一约束的时候，数据库会自动创建相应的索引。  
2. 查看索引
```text
show indexes from table_name
```
3. 删除索引
```
drop index index_name
```
4. 查看执行计划
```
explain + sql 语句
```
## 查询性能优化
### 创建合适的索引
1. 基于经常出现在where条件中的字段建立索引，可以避免全表扫描
2. 基于多表连接字段建索引，可以提高连接查询的速度
3. 将group by分组字段加入索引，可以利用索引实现分组
4. 将order by排序字段加入索引，可以避免额外的排序操作。
### 避免索引失效
1. 在查询条件中对索引字段进行运算，或者使用函数会导致索引失效
2. 使用like模糊查询，通配符出现在左侧会导致索引失效（最左匹配原则）
### 优化返回的数据
1. 只查询需要的列，不要用select *
2. 返回必要的行，使用limmit限制行数
3. 使用缓存，缓存重复数据。减少数据库压力
### 重构查询方式
1. 切分大查询
* 一个大查询一次执行的话，锁住很多数据表，阻塞很多小的查询。
2. 分解大连接查询
将一个大连接查询分解成对每个表的单表查询，然后在应用程序中进行关联，这样做的好处有：
* 让缓存更高效，如果是大连接查询，缓存的数据会因一张表的内容改变而失效，但是，单表查询数据，缓存数据粒度很细。数据有效性更高。
* 可以减少锁的竞争。
* 在应用层进行连接，可以更容易对数据库进行拆分。

### 分表
1. 水平切分，可以使用id进行hash,将不同数据分布在集群的不同节点上，从而减轻对单个数据库查询的压力。
2. 垂直切分，将一张表按照列切分为多张表，通常是按照列的关系密集关系进行切分，例如将电商数据表切分为商品表和用户表。
