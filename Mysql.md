# Mysql
## 索引
### 索引原理
数据库如何查找我们所需的数据呢？如果没有索引，会进行全表扫描，这样如果数据表数据很大，会有很多次I/O操作，磁盘I/O会大大降低性能。为减少I/O操作引入了索引，底层使用B+树，将索引列加载到内存，数据全部在叶子节点，可以大大减少I/O操作，并且可以很快定位到我们所需要的数据，只需要很少的I/O操作将我们所需数据加载到内存放回就行，不需要将全表内容加载到内存。  
<div align="center">
<img src=https://user-images.githubusercontent.com/34670345/175211944-c773dcc9-cb24-426c-99e7-482cec78e3cf.jpg height=350px />
</div>

### 分类
* 按照存储结构分类
1. 聚集索引：叶子节点存储了数据，不是指向数据的指针。
2. 非聚集索引：叶子阶段存储了指向数据的指针。
* 按照应用角度分类
1. 唯一索引：可以确保被索引的字段不存在重复值。
2. 单列索引，在单个字段上创建的索引。
3. 多列索引，在多个字段组合创建索引，也称为复合索引。

### 索引维护
1. 索引创建
```text
creat [unique] index index_name on table_name(coll [ASC|DESC], ...);
```
ASC: 升序，DESC: 降序，unique:唯一索引。我们创建主键和唯一约束的时候，数据库会自动创建相应的索引。  
2. 查看索引
```text
show indexes from table_name
```
3. 删除索引
```
drop index index_name
```
4. 查看执行计划
```
explain + sql 语句
```
## 查询性能优化
### 创建合适的索引
1. 基于经常出现在where条件中的字段建立索引，可以避免全表扫描
2. 基于多表连接字段建索引，可以提高连接查询的速度
3. 将group by分组字段加入索引，可以利用索引实现分组
4. 将order by排序字段加入索引，可以避免额外的排序操作。
### 避免索引失效
1. 在查询条件中对索引字段进行运算，或者使用函数会导致索引失效
2. 使用like模糊查询，通配符出现在左侧会导致索引失效（最左匹配原则）
### 优化返回的数据
1. 只查询需要的列，不要用select *
2. 返回必要的行，使用limmit限制行数
3. 使用缓存，缓存重复数据。减少数据库压力
### 重构查询方式
1. 切分大查询
* 一个大查询一次执行的话，锁住很多数据表，阻塞很多小的查询。
2. 分解大连接查询
将一个大连接查询分解成对每个表的单表查询，然后在应用程序中进行关联，这样做的好处有：
* 让缓存更高效，如果是大连接查询，缓存的数据会因一张表的内容改变而失效，但是，单表查询数据，缓存数据粒度很细。数据有效性更高。
* 可以减少锁的竞争。
* 在应用层进行连接，可以更容易对数据库进行拆分。

### 分表
1. 水平切分，可以使用id进行hash,将不同数据分布在集群的不同节点上，从而减轻对单个数据库查询的压力。
2. 垂直切分，将一张表按照列切分为多张表，通常是按照列的关系密集关系进行切分，例如将电商数据表切分为商品表和用户表。

### Mysql数据库事务的基本特征？靠什么保证？
* ACID: 分别是原子性，一致性，隔离性，持久性。
* 原子性: 是指一个事务的所有操作要么都执行成功，要么都执行失败。undo日志记录了需要回滚的事务，通过undo日志，将执行失败的事务回滚，保证原子性。
* 一致性: 数据库从一个状态转移到另一个状态，一般由代码层面实现。
* 隔离性: 事务提交前，对其他事务的不可见性。MVCC实现。
* 持久性: 事务一旦提交，数据会持久保存在数据库。通过内存+redo日志，修改数据，在内存和redo日志中记录该操作，事务提交会，将redo日志刷盘，持久保存。

### 数据库的隔离性有那些？
* read-uncommit: 读未提交，有脏读，不可重复读，幻读问题
* read-commit: 读已提交，有不可重复读，幻读问题
* reapeatable-commit: 可重复读，有幻读问题。
* serializable: 序列化，

### 脏读，不可重复读，幻读？
* 脏读: A，B两个事务，B事务读取到A事务修改未提交的数据。造成数据的错误。
* 不可重复读: A事务多次读取数据过程中，B事务updata了数据，使得多次事务读取的数据不一致。
* 幻读: A事务查询数据条数，B事务执行插入或删除操作，使得A事务查询数据不一致。

### 什么是MVCC ?
* 多版本并发控制，每个数据表都有两个隐藏字段，创建时间版本号，过期时间版本号，每开启一个事务，版本号+1。
* 查询时，查询创建版本号<=当前版本号&&（过期版本号>当前版本号||过期版本号为空）的数据。
* 这样保证了，查询数据时开启事务之前的数据或者是本身事务修改后的数据。
