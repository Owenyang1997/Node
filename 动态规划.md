# 动态规划
## 题目列表
* [拼接数组的最大分数](https://leetcode.cn/problems/maximum-score-of-spliced-array/)
* [一和零](https://leetcode.cn/problems/ones-and-zeroes/)
* [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum)
* [零钱兑换](https://leetcode.cn/problems/coin-change/)
* [目标和](https://leetcode.cn/problems/target-sum/description/)
* [零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)
* [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)
* [顺丰02.小哥派件装载问题](https://leetcode.cn/contest/sf-tech/problems/cINqyA/)
* [最大正方形](https://leetcode.cn/problems/maximal-square/)
* [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
* [最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
* [不同路径II](https://leetcode.cn/problems/unique-paths-ii/)
* [ 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
* [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
* [01 矩阵](https://leetcode.cn/problems/01-matrix/)

## 回文串问题
* [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
思路：
  i~j的子段最大长度，如果 s[i]==s[j] 那么 f[i][j]=f[i+1][j-1]+2; 否则 f[i][j] 从 f[i+1][j] 和 f[i][j-1] 中取最大值。   
Code:
```java
 public int longestPalindromeSubseq(String s) {
        int n=s.length();
        int [][]f=new int[n][n];
        for(int i=0;i<n;i++) f[i][i]=1;
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                  f[i][j]=f[i+1][j-1]+2;
                }else f[i][j]=Math.max(f[i][j-1],f[i+1][j]);
            }
        }
        return f[0][n-1];
    }
```

## 最大子段和
* [最大连续子段和]()
* [最大序列和，不连续]()

## 路径问题
* []()
* []()


## 背包问题
### 0-1背包问题  
[Acwing](https://www.acwing.com/problem/content/2/)
问题描述：

```

```
#### 背包变形（求最优解，背包数量不是一个）
[力扣](https://leetcode.cn/problems/ones-and-zeroes/submissions/)
问题描述：  
给你一个二进制字符串数组strs和两个整数m和n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1
```text
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 
```
思路：多一重遍历就可以了。
```java
 public int findMaxForm(String[] strs, int m, int n) {
        int [][]f=new int[m+1][n+1];
        for(int i=0;i<strs.length;i++){
            int []num=get(strs[i]);
            for(int j=m;j>=num[0];j--){
                for(int k=n;k>=num[1];k--){
                    f[j][k]=Math.max(f[j][k],f[j-num[0]][k-num[1]]+1);
                }
            }
        }
        return f[m][n];

    }
    private int[] get(String str){
        int n=0,m=0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='0') m++;
            else n++;
        }
        return new int[]{m,n};
    }
```
#### 背包变形 (背包装满问题)
1. [力扣](https://leetcode.cn/problems/partition-equal-subset-sum/)
问题描述:  
给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  
```text
示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。  
```
思路：  
    与01背包一样，W是背包容量，V是物品重量，我们需要考虑对于每个物品，每个容量的背包是否能被装满。    
所以对于每个物品，我们的背包f[j]的状态取决于装当前物品：f[j-w]的状态和不装当前物品的状态f[j]决定。

```java
public boolean canPartition(int[] nums) {
        int sum=0,n=nums.length;
        for(int i=0;i<n;i++) sum+=nums[i];
        if(sum%2!=0) return false;
        int tagter=sum/2;
        boolean []f=new boolean[tagter+1];
        f[0]=true;//容量是0的时候 正好装满
        for(int i=0;i<n;i++){
            for(int j=tagter;j>=nums[i];j--){//每个物品只能用一次，所以需要从后往前遍历。
                f[j]=f[j]||f[j-nums[i]]; //装nums[i]和不装 nums[i]两个状态转移得到结果
            }
        }
        return f[tagter];
    }
```
2. [力扣](https://leetcode.cn/problems/coin-change/) 
问题描述:   
   给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。
计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。
```text
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
``` 
属于完全背包的变形体，和第一题类似。问题转化：物品无限使用，使用最少的物品数装满背包，求最少使用数量，也就是每个物品的value是1 在背包装满的时候最小value是多少?  

思路：  
  f[j]表示j容量的背包 最小value。对于每个物品，我们可以更新每个求得每个容量下背包的最优结果，但是如果装不满value值应该是很大。
所以我们的初始化应该是所有容量的背包value很大，f[0]的背包value=0;
状态转移：f[j]=min(f[j],f[j-w]+1); 并且是从前往后遍历。

```java
    int mav=100000;
    public int coinChange(int[] coins, int amount) {
        int []f=new int[amount+1];
        Arrays.fill(f,mav);
        f[0]=0;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                f[j]=Math.min(f[j],f[j-coins[i]]+1);
            }
        }
        return f[amount]==mav?-1:f[amount];
    }
```
3. [力扣](https://leetcode.cn/problems/target-sum/description/)
问题描述：  
给你一个整数数组nums和一个整数 target。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1"。返回可以通过上述方法构造的、运算结果等于target 的不同表达式的数目。
```text
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```
思路：  
所有负数有p个, 正数有q个 : q-p = target  --> q+p+q-p =target+sum --> 2q= target+sum  --> q=(target+sum)/2 存在这样的q就行。
存在一个集合，以上条件即可。
也就是划分子集，和为target1=(target+sum)/2。的子集个数。
```java
public int findTargetSumWays(int[] nums, int target) {
        if(target<0) target=-target;
        int sum=0;
        for(int i=0;i<nums.length;i++) sum+=nums[i];
        if(sum<target||(sum+target)%2!=0) return 0;
        int t=(sum+target)/2;
        int []f=new int[t+1];
        f[0]=1;
        for(int i=0;i<nums.length;i++){
            for(int j=t;j>=nums[i];j--){
                f[j]+=f[j-nums[i]];
            }
        }
        return f[t];
    }
```

#### 背包变形（求方案数）
1. [力扣](https://leetcode.cn/problems/coin-change-2/)
问题描述：  
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回0。假设每一种面额的硬币有无限个。
```text
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
思路：     
属于完全背包的变形，物品无限次数使用，我们记录每个容量下组合数个数，这样在每个物品情况下我们更新每个背包容量的组合个数。
转移方程：f[j]+=f[j-w]       
初始：全都是0，f[0]=1;
```java
public int change(int amount, int[] coins) {
        int []f=new int[amount+1];
        f[0]=1;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                f[j]+=f[j-coins[i]];
            }
        }
        return f[amount];
    }
```
2. [力扣](https://leetcode.cn/problems/combination-sum-iv/)
问题描述：
给你一个由不同整数组成的数组 nums，和一个目标整数target。请你从nums中找出并返回总和为target的元素组合的个数。题目数据保证答案符合 32 位整数范围。
```text
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```
思路：  
与分硬币的求方案数一样，每个物品，我们更新每个背包的方案数，从前往后，f[j]+=f[j-nums[i]]; 但是需要注意的是，不同顺序是不同组合，所以我们需要改变内外循环，把物品放在内循环。 如果物品在外循环，每次计算 f[j] 都是使用 i 个物品的情况。没有使用所有的物品。
```java
public int combinationSum4(int[] nums, int target) {
        int []f=new int[target+1];
        f[0]=1;
        for(int i=0;i<=target;i++){
            for(int j:nums){
                if(i>=j) f[i]+=f[i-j];
            }
        }
        return f[target];
    }
```

#### 背包变形（缺少物品的价值）
1. [力扣](https://leetcode.cn/contest/sf-tech/problems/cINqyA/)
问题描述：  
快递小哥每天都需要揽件并骑电瓶车派送快递，假设电瓶车快递箱容量为V，小哥需要派送n个快递，每个快递都有一定的体积大小。
要求在需要派送的n个快递中，任取若干个快递装放入快递箱，不能溢出，使快递箱的剩余空间最小。
```text
输入：N = [8, 1, 12, 7, 9, 7], V = 11
输出：1
解释：快递箱容量V为11，物品体积数组N为[8, 1, 12, 7, 9, 7],最优解为取体积为
1的快递和体积为9的快递,即快递箱剩余最小空间为 11-(1+9)=1
```
思路：  
这属于01背包问题，不要求装满背包。这个可以将问题转化，每个物品重量和价值是相等的，求最大价值是多少？
每个物品，我们求每个背包的最大价值。f[j]=max(f[j],f[j-w]+nums[i])
```java
class Solution {
    public int minRemainingSpace(int[] N, int V) {
        int []f=new int[V+1];
        for(int i=0;i<N.length;i++){
            for(int j=V;j>=N[i];j--){
                f[j]=Math.max(f[j],f[j-N[i]]+N[i]);
            }
        }
        return V-f[V];
    }
}
```
