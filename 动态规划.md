# 动态规划
## 0-1背包问题  
[Acwing](https://www.acwing.com/problem/content/2/)
问题描述：

```

```
## 背包变形 (背包装满问题)
1. [力扣](https://leetcode.cn/problems/partition-equal-subset-sum/)
问题描述:  
给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  
```text
示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。  
```
思路：  
    与01背包一样，W是背包容量，V是物品重量，我们需要考虑对于每个物品，每个容量的背包是否能被装满。    
所以对于每个物品，我们的背包f[j]的状态取决于装当前物品：f[j-w]的状态和不装当前物品的状态f[j]决定。

```java
public boolean canPartition(int[] nums) {
        int sum=0,n=nums.length;
        for(int i=0;i<n;i++) sum+=nums[i];
        if(sum%2!=0) return false;
        int tagter=sum/2;
        boolean []f=new boolean[tagter+1];
        f[0]=true;//容量是0的时候 正好装满
        for(int i=0;i<n;i++){
            for(int j=tagter;j>=nums[i];j--){//每个物品只能用一次，所以需要从后往前遍历。
                f[j]=f[j]||f[j-nums[i]]; //装nums[i]和不装 nums[i]两个状态转移得到结果
            }
        }
        return f[tagter];
    }
```
2. [力扣](https://leetcode.cn/problems/coin-change/) 
问题描述:   
   给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。
计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。
```text
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
``` 
属于完全背包的变形体，和第一题类似。问题转化：物品无线使用，使用最少的物品数装满背包，求最少使用数量，也就是每个物品的value是1 在背包装满的时候最小value是多少?  

思路：  
  f[j]表示j容量的背包 最小value。对于每个物品，我们可以更新每个求得每个容量下背包的最优结果，但是如果装不满value值应该是很大。
所以我们的初始化应该是所有容量的背包value很大，f[0]的背包value=0;
状态转移：f[j]=min(f[j],f[j-w]+1); 并且是从前往后遍历。

```java
    int mav=100000;
    public int coinChange(int[] coins, int amount) {
        int []f=new int[amount+1];
        Arrays.fill(f,mav);
        f[0]=0;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                f[j]=Math.min(f[j],f[j-coins[i]]+1);
            }
        }
        return f[amount]==mav?-1:f[amount];
    }
```
## 背包变形（求方案数）
[力扣]https://leetcode.cn/problems/coin-change-2/
问题描述：  
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回0。假设每一种面额的硬币有无限个。
```text
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
思路：     
属于完全背包的变形，物品无限次数使用，我们记录每个容量下组合数个数，这样在每个物品情况下我们更新每个背包容量的组合个数。
转移方程：f[j]+=f[j-w]       
初始：全都是0，f[0]=1;
```java
public int change(int amount, int[] coins) {
        int []f=new int[amount+1];
        f[0]=1;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                f[j]+=f[j-coins[i]];
            }
        }
        return f[amount];
    }
```
