## 哈希表

* [连续数组](https://leetcode.cn/problems/contiguous-array/)  
思路：  
前缀和，将0变为-1，如果i 下标对于的和是0 表明 (0-i)内 0和1个数相同--> ans=max(ans,i+1)  
如果 i 下标 对应的 和 是 k 说明 需要 一个 和是 x 的前缀和的下标j。 满足 k-x=0 --> (j~i)子段和 为 0 如果存在这样的前缀和我们更新 ans=max(ans,i-hash.get(k))。  
否则 我们 将前缀和 存储 在 hashmap中。
```java
 public int findMaxLength(int[] nums) {
        HashMap<Integer,Integer> hash=new HashMap();
        int s=0,ans=0;
        for(int i=0;i<nums.length;i++){
            s+=nums[i]==0?-1:1;
            if(s==0) ans=Math.max(ans,i+1);
            else if(hash.containsKey(s)) ans=Math.max(ans,i-hash.get(s));
            else hash.put(s,i);
        }
        return ans;

    }
```
* [连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

```java
public boolean checkSubarraySum(int[] nums, int k) {
        int s=0;
        HashMap<Integer,Integer> hash=new HashMap();
        for(int i=0;i<nums.length;i++){
            s+=nums[i];
            if(i>1&&nums[i]==0&&nums[i-1]==0) return true;
            if(s%k==0&&i>=1) return true;
            int t=s%k;
            if(hash.containsKey(t)){
                if(i-hash.get(t)>=2) return true;
            }
            if(nums[i]==0) hash.put(0,i);
            else hash.put(t,i);
        }
        return false;

    }
```
