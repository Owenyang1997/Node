## 递归

## 模板
* 模板一
```java
    private void dfs(int []nums,int i){
        if(i==nums.length){
            ans.add(new ArrayList(path));
            return;
        }
        path.add(nums[i]);
        dfs(nums,nums[i],i+1);
        path.removeLast();
    }
```

* 模板二
```java
 private void dfs(int []nums,int i){
        if(i==nums.length){
            ans.add(new ArrayList(path));
            return;
        }
        for(int k=i;k<nums.length;k++){
            path.add(nums[k]);
            dfs(nums,nums[k],k+1);
            path.removeLast();
        }
    }
```

两个模板一个是需要 for 循环 循环我们的选择。一个是没有 for 循环 如何选择模板？
1. 首先我们的每一步都有选择方案，如果选择方案有很多，需要 for 
2. 如果只有两个选择：使用这个数和不使用这个数 则不需要 for
## 求组合数  
* [递增子序列](https://leetcode.cn/problems/increasing-subsequences/)  
思路:  
1. 确定模板：对于数组中每个数据，递归内部我们只有两个选择 使用这个数据 不用这个数据，所以不用 for  
2. 确定函数定义：我们在循环过程中需要拿到上次使用的数据。所以增加子段 last 存储上次使用的数据，我们需要知道当前到那个数据了，使用下标 i 表示我们处理到那个数据--> 所以 递归函数定义：dfs(int i,int last,int []nums){}  
3. 判断什么时候使用 该数据 --> 满足条件，当前的数据大于等于上次选择的数据
4. 判断什么时候不用 该数据 --> last>cur（无法使用） 或者 last<cur (可以不用) 如果 last==cur 我们是否可以不用该数据？ 如果不用那么 一定会有重复 比如 1，2，7，7
其中1，2，7就会重复，因为我们无法确定 7 这个数据是 第一次 出现 7 的时候的结果 还是 出现第二 7 并未使用的结果。导致重复。所以 相等我们就必须使用该数据。所以不用数据的条件是 last!=cur。
```java
    List<List<Integer>> ans=new ArrayList();
    LinkedList<Integer> path=new LinkedList();
    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(nums,Integer.MIN_VALUE,0);
        return ans;
    }
    
    private void dfs(int []nums,int last,int i){
        if(i==nums.length){
            if(path.size()>1) ans.add(new ArrayList(path));
            return;
        }
        if(last<=nums[i]){
            path.add(nums[i]);
            dfs(nums,nums[i],i+1);
            path.removeLast();
        }
        if(last!=nums[i]) dfs(nums,last,i+1);
    }
```
